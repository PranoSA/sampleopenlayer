<html>
<head>
    <title>Home</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <!-- Include OpenLayers CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol/ol.css" type="text/css">
    <style>
        .map {
            width: 100%;
            height: 1000px; /* Adjust the height as needed */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Home</h1>
        </div>
        <div class="content">
            <!-- Map Container -->
            <div id="map" class="map"></div>
        </div>

        <div id="info" style="position: absolute; top: 10px; right: 10px; background: white; padding: 10px; border: 1px solid black; z-index: 1000;">Click on a point</div>
    </div>
    <!-- Include OpenLayers JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/ol@v9.2.4/dist/ol.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v9.2.4/ol.css">

    <script>

        let vectorSource = new ol.source.Vector({
            url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Power_Plants&outputFormat=application/json',
            format: new ol.format.GeoJSON()
        })

        let tranmissionLineLayer = new ol.layer.Vector({
            // ne:Electric_Power_Transmission_Lines_A
            // geoserver localhost:3000/api
            source: new ol.source.Vector({
                url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&CQL_FILTER=VOLTAGE>700',
                format: new ol.format.GeoJSON()
            }),
        })

        let heatMapLayer = new ol.layer.Heatmap({
            source: vectorSource,
            blur: 15,
            radius: 5, 
        })

        var clusterSource = new ol.source.Cluster({
            distance: 50,
            source: vectorSource
        })


        // size Cluster based on Total_MW property

        function clusterStyleFunction(feature) {
            var features = feature.get('features');

            var totalMW = features.reduce(function(sum, feature) {
                return sum + (feature.get('Total_MW') || 0); // Sum up the Total_MW property, defaulting to 0 if undefined
            }, 0);
            //Adjust size based on zoom 

            let zoom = map.getView().getZoom();
            console.log("Zoom: " + zoom)
            var size = 10;
            
            if(zoom > 10){
                size = Math.min(30, 10+ totalMW / 10); // Limit the size to 40 (or adjust as needed
            }
            if (zoom > 5 && zoom < 10){
                size = Math.min(30,10+ totalMW / 1000); // Limit the size to 40 (or adjust as needed
            }

            if (zoom < 5){
                size = Math.min(20, 5+ totalMW / 10000); // Limit the size to 40 (or adjust as needed
            }
            
            console.log("Size: " + size)

            

           // var size = Math.min(20, 0+ totalMW / 10); // Limit the size to 40 (or adjust as needed
            var style = new ol.style.Style({
                image: new ol.style.Circle({
                    radius: size,
                    stroke: new ol.style.Stroke({
                        color: '#fff'
                    }),
                    fill: new ol.style.Fill({
                        color: '#3399CC'
                    })
                }),
                text: new ol.style.Text({
                    text : totalMW > 1000000 ? Math.round((totalMW/1000000)).toString()+"TW": totalMW > 1000 ? Math.round((totalMW/1000)).toString() + 'GW' : Math.round(totalMW).toString()+"MW",
                    fill: new ol.style.Fill({
                        color: '#000',

                    }),
                })
            });
            return style;
        }

        var clusterLayer = new ol.layer.Vector({
            source: clusterSource,
            style: clusterStyleFunction
        });

       /* var transmissionLineLayer = new ol.layer.Vector({
            source: new ol.source.Vector({
               // url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json',
               url : "http://your-wfs-service-url?service=WFS&version=2.0.0&request=GetFeature&typeName=your:layerName&outputFormat=application/json&CQL_FILTER=VOLTAGE>700", 
               format: new ol.format.GeoJSON()
            }),
        })*/



        
        

        // Add A Layer transmission Line with custom onclick event
        // var tranmissionLineLayer = new ol.layer.Vector({
        //     source: new ol.source.Vector({
        //         url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json',
        //         format: new ol.format.GeoJSON()
        //     }),
        //     style: new ol.style.Style({
        //         stroke: new ol.style.Stroke({
        //             color: 'rgba(0, 0, 255, 1.0)',
        //             width: 2
        //         })
        //     })
        // });

        let vectorTransmissionLayerOut;


        // Initialize the Map
        var map = new ol.Map({
            target: 'map', // The ID of the map container
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM() // OpenStreetMap as the source
                }),
                clusterLayer,
                heatMapLayer,
                //tranmissionLineLayer,
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([0, 0], 'EPSG:3857'), // Center of the map
                zoom: 2, // Initial zoom level
                projection: 'EPSG:3857'
            }),

        });
        //map.addLayer(tranmissionLineLayer);

        //http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&
        function fetchFeatures(wfsUrl) {
    // add vector layer
    
    // remove the previous layer
    map.removeLayer(vectorTransmissionLayerOut);

    var vectorTransmissionLayer = new ol.layer.Vector({
        source: new ol.source.Vector({
            format: new ol.format.GeoJSON(),
            url: wfsUrl
        })
    });

    vectorTransmissionLayerOut = vectorTransmissionLayer;
    console.log("Adding Layer")
    console.log(vectorTransmissionLayer)
    map.addLayer(vectorTransmissionLayer);

}
let previousZoom = 15;

        map.getView().on('change:resolution', function() {
    var zoom = map.getView().getZoom();
    console.log("zoom level: " + zoom)
    
    if (zoom < 8 && previousZoom > 8) {
        filter = 'VOLTAGE>700';
    } else if (zoom >= 8 && zoom < 12 && (previousZoom < 8 || previousZoom >= 12)) {
        filter = 'VOLTAGE>200';
    } else if (zoom >= 12 && previousZoom < 12) {
        filter = 'INCLUDE'; // OGC's way of saying "no filter"
    }
    // case it hasn't changed at all
    else {
        return;
    }
    
    function encodeURIComponentRFC3986(str) {
        return str;
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return '%' + c.charCodeAt(0).toString(16);
    })};

    previousZoom = zoom;
    //fetchFeatures(wfsUrl); // Your function to fetch and process the WFS data

    var extent = map.getView().calculateExtent(map.getSize());
    var projection = map.getView().getProjection();
    var wfsProjection = 'EPSG:3857'; // The projection used by your WFS service
    var transformedExtent = ol.proj.transformExtent(extent, projection, wfsProjection);

    // Construct the BBOX filter string
    var bboxFilter = `BBOX(the_geom,${transformedExtent.join(',')})`;

    // Combine your existing filter with the BBOX filter
    var combinedFilter = `${filter} AND ${bboxFilter}`;


    var wfsUrl = `http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&CQL_FILTER=${encodeURIComponent(combinedFilter)}`;
   // var wfsUrl = `http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&CQL_FILTER=${filter}`;
   console.log("wfsUrl" + " " + wfsUrl);

    
    map.removeLayer(vectorTransmissionLayerOut);

    var vectorTransmissionLayer = new ol.layer.Vector({
        source: new ol.source.Vector({
            format: new ol.format.GeoJSON(),
            url: wfsUrl
        })
    });

    vectorTransmissionLayerOut = vectorTransmissionLayer;
    console.log("Adding Layer")
    console.log(vectorTransmissionLayer)
    map.addLayer(vectorTransmissionLayer);
    

    // Tile Vecto here -> With the filter including
    //%3A900913
  /*  filter = 'VOLTAGE>700';
    var vectorTileUrl = `http://localhost:3000/api/geoserver/gwc/service/tms/1.0.0/ne:Electric_Power_Transmission_Lines_A@EPSG%3A900913@pbf/CQL_FILTER=${filter}/{z}/{y}/{x}.pbf`;
    

    // new tile layer 
    let vectorTranmissionLayer = new ol.layer.VectorTile({
        source: new ol.source.VectorTile({
            tilePixelRatio: 1, // oversampling when > 1
            projection: 'EPSG:3857',
            format: new ol.format.MVT({
            }),
            tileGrid: ol.tilegrid.createXYZ({
                maxZoom: 19,
            }),
            url: vectorTileUrl
        })
    });

    map.addLayer(vectorTranmissionLayer);


    vectorTransmissionLayerOut = vectorTileLayer;

    previousZoom = zoom;
    */
   
});

        map.on('singleclick', function(event) {
    // Use the map's forEachFeatureAtPixel method to check for features at the click location
    map.forEachFeatureAtPixel(event.pixel, function(feature, layer) {
        // Check if the layer is the transmissionLineLayer
        if (layer === vectorTransmissionLayerOut) {
            // Log the feature to the console
            console.log(feature);
            // Optionally, return the feature if you only want the first feature found
            return feature;
        }
    }, {
        // Specify the layer(s) to include in the search
        layerFilter: function(candidateLayer) {
            return candidateLayer === vectorTransmissionLayerOut;
        }
    });
});
        

        map.on('singleclick', function(evt) {
    var infoPanel = document.getElementById('info');
    var featureFound = false;
    map.forEachFeatureAtPixel(evt.pixel, function(feature, layer) {
        // Assuming your features have properties you want to display
        // Adjust this to match the actual properties of your features
        var properties = feature.getProperties();
        console.log(properties);
        var infoContent = 'Power Plant Name: ' + properties.Plant_Name; // Example property
        infoPanel.innerHTML = infoContent;
        featureFound = true;
    });

    map.on('moveend', function() {
    var zoom = map.getView().getZoom();
    // Adjust clusterSource distance or clusterLayer style based on zoom
    // For example, disable clustering at high zoom levels  
    var certainZoomLevel = 10;
    if (zoom > certainZoomLevel) {
        clusterSource.setDistance(0); // No clustering
    } else {
        clusterSource.setDistance(40); // Adjust distance as needed
    }
});

    if (!featureFound) {
        infoPanel.innerHTML = 'Click on a point';
    }
});
    </script>
</body>
</html>