<html>
<head>
    <title>Home</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <!-- Include OpenLayers CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol/ol.css" type="text/css">
    <link rel="stylesheet" type="text/css" href="index.css">
    <style>
        .map {
            width: 100%;
            height: 1000px; /* Adjust the height as needed */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Home</h1>
        </div>
        <div class="content">
            <!-- Map Container -->
            <div id="map" class="map"></div>
        </div>

        <div id="popup" class="ol-popup">
            <a href="#" id="popup-closer" class="ol-popup-closer"></a>
            <div id="popup-content"></div>
        </div>

        <div id="info" style="position: absolute; top: 10px; right: 10px; background: white; padding: 10px; border: 1px solid black; z-index: 1000;">Click on a point</div>
    </div>
    <!-- Include OpenLayers JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/ol@v9.2.4/dist/ol.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v9.2.4/ol.css">

    <script>

        let vectorSource = new ol.source.Vector({
            url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Power_Plants&outputFormat=application/json',
            format: new ol.format.GeoJSON()
        })

        var container = document.getElementById('popup');
        var content = document.getElementById('popup-content');
        var closer = document.getElementById('popup-closer');

        // Create an overlay to anchor the popup to the map.
        var overlay = new ol.Overlay({
            element: container,
            autoPan: true,
            autoPanAnimation: {
                duration: 250
            }
        });
        

        // Close the popup when the close button is clicked
    closer.onclick = function() {
        overlay.setPosition(undefined);
        closer.blur();
        return false;
    };

        let tranmissionLineLayer = new ol.layer.Vector({
            // ne:Electric_Power_Transmission_Lines_A
            // geoserver localhost:3000/api
            source: new ol.source.Vector({
                url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&CQL_FILTER=VOLTAGE>700',
                format: new ol.format.GeoJSON()
            }),
        })

        let heatMapLayer = new ol.layer.Heatmap({
            source: vectorSource,
            blur: 15,
            radius: 5, 
        })

        var clusterSource = new ol.source.Cluster({
            distance: 50,
            source: vectorSource
        })


        // size Cluster based on Total_MW property

        function clusterStyleFunction(feature) {
            var features = feature.get('features');

            var totalMW = features.reduce(function(sum, feature) {
                return sum + (feature.get('Total_MW') || 0); // Sum up the Total_MW property, defaulting to 0 if undefined
            }, 0);
            //Adjust size based on zoom 

            let zoom = map.getView().getZoom();
            console.log("Zoom: " + zoom)
            var size = 10;
            
            if(zoom > 10){
                size = Math.min(30, 10+ totalMW / 10); // Limit the size to 40 (or adjust as needed
            }
            if (zoom > 5 && zoom < 10){
                size = Math.min(30,10+ totalMW / 1000); // Limit the size to 40 (or adjust as needed
            }

            if (zoom < 5){
                size = Math.min(20, 5+ totalMW / 10000); // Limit the size to 40 (or adjust as needed
            }
            
            console.log("Size: " + size)

            

           // var size = Math.min(20, 0+ totalMW / 10); // Limit the size to 40 (or adjust as needed
            var style = new ol.style.Style({
                image: new ol.style.Circle({
                    radius: size,
                    stroke: new ol.style.Stroke({
                        color: '#fff'
                    }),
                    fill: new ol.style.Fill({
                        color: '#3399CC'
                    })
                }),
                text: new ol.style.Text({
                    text : totalMW > 1000000 ? Math.round((totalMW/1000000)).toString()+"TW": totalMW > 1000 ? Math.round((totalMW/1000)).toString() + 'GW' : Math.round(totalMW).toString()+"MW",
                    fill: new ol.style.Fill({
                        color: '#000',

                    }),
                })
            });
            return style;
        }

        var clusterLayer = new ol.layer.Vector({
            source: clusterSource,
            style: clusterStyleFunction
        });

       /* var transmissionLineLayer = new ol.layer.Vector({
            source: new ol.source.Vector({
               // url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json',
               url : "http://your-wfs-service-url?service=WFS&version=2.0.0&request=GetFeature&typeName=your:layerName&outputFormat=application/json&CQL_FILTER=VOLTAGE>700", 
               format: new ol.format.GeoJSON()
            }),
        })*/



        
        

        // Add A Layer transmission Line with custom onclick event
        // var tranmissionLineLayer = new ol.layer.Vector({
        //     source: new ol.source.Vector({
        //         url: 'http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json',
        //         format: new ol.format.GeoJSON()
        //     }),
        //     style: new ol.style.Style({
        //         stroke: new ol.style.Stroke({
        //             color: 'rgba(0, 0, 255, 1.0)',
        //             width: 2
        //         })
        //     })
        // });

        let vectorTransmissionLayerOut;


        // Initialize the Map
        var map = new ol.Map({
            target: 'map', // The ID of the map container
            layers: [
                new ol.layer.Tile({
                    source: new ol.source.OSM() // OpenStreetMap as the source
                }),
             /*   new ol.layer.Tile({
    source: new ol.source.TileWMS({
        url: 'http://localhost:3000/api/ows/geoserver', // GeoServer WMS service URL
        params: {
            //Service
            'SERVICE': 'WMS',
            'LAYERS': 'tiger:giant_polygon', // Specify the GeoServer layer to display
            'TILED': true,
            'VERSION': '1.1.1' // WMS version (optional, depending on your GeoServer setup)
        },
        serverType: 'geoserver' // Optional, but can be set for better integration with GeoServer
    })
}),*/
                clusterLayer,
                //heatMapLayer,
                tranmissionLineLayer,
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([-98.5795, 39.8283], 'EPSG:3857'), // Center of the map
                zoom: 4, // Initial zoom level
                projection: 'EPSG:3857'
            }),

        });

        map.addOverlay(overlay);
        //map.addLayer(tranmissionLineLayer);

        //http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&
        function fetchFeatures(wfsUrl) {
    // add vector layer
    
    // remove the previous layer
    map.removeLayer(vectorTransmissionLayerOut);

    var vectorTransmissionLayer = new ol.layer.Vector({
        source: new ol.source.Vector({
            format: new ol.format.GeoJSON(),
            url: wfsUrl
        })
    });

    vectorTransmissionLayerOut = vectorTransmissionLayer;
    console.log("Adding Layer")
    console.log(vectorTransmissionLayer)
    map.addLayer(vectorTransmissionLayer);

}
let previousZoom = 15;

        map.getView().on('change:resolution', function() {
    var zoom = map.getView().getZoom();
    console.log("zoom level: " + zoom)
    
    if (zoom < 8 && previousZoom > 8) {
        filter = 'VOLTAGE>700';
    } else if (zoom >= 8 && zoom < 12 && (previousZoom < 8 || previousZoom >= 12)) {
        filter = 'VOLTAGE>200';
    } else if (zoom >= 12 && previousZoom < 12) {
        filter = 'INCLUDE'; // OGC's way of saying "no filter"
    }
    // case it hasn't changed at all
    else {
        return;
    }
    
    function encodeURIComponentRFC3986(str) {
        return str;
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return '%' + c.charCodeAt(0).toString(16);
    })};

    previousZoom = zoom;
    //fetchFeatures(wfsUrl); // Your function to fetch and process the WFS data

    var extent = map.getView().calculateExtent(map.getSize());
    var projection = map.getView().getProjection();
    var wfsProjection = 'EPSG:3857'; // The projection used by your WFS service
    var transformedExtent = ol.proj.transformExtent(extent, projection, wfsProjection);

    // Construct the BBOX filter string
    var bboxFilter = `BBOX(the_geom,${transformedExtent.join(',')})`;

    // Combine your existing filter with the BBOX filter
    var combinedFilter = `${filter} AND ${bboxFilter}`;


    var wfsUrl = `http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&CQL_FILTER=${encodeURIComponent(combinedFilter)}`;
   // var wfsUrl = `http://localhost:3000/api/geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=ne:Electric_Power_Transmission_Lines_A&outputFormat=application/json&CQL_FILTER=${filter}`;
   console.log("wfsUrl" + " " + wfsUrl);

    
    map.removeLayer(vectorTransmissionLayerOut);

    var vectorTransmissionLayer = new ol.layer.Vector({
        source: new ol.source.Vector({
            format: new ol.format.GeoJSON(),
            url: wfsUrl
        })
    });

    vectorTransmissionLayerOut = vectorTransmissionLayer;
    console.log("Adding Layer")
    console.log(vectorTransmissionLayer)
    map.addLayer(vectorTransmissionLayer);
    

    // Tile Vecto here -> With the filter including
    //%3A900913
  /*  filter = 'VOLTAGE>700';
    var vectorTileUrl = `http://localhost:3000/api/geoserver/gwc/service/tms/1.0.0/ne:Electric_Power_Transmission_Lines_A@EPSG%3A900913@pbf/CQL_FILTER=${filter}/{z}/{y}/{x}.pbf`;
    

    // new tile layer 
    let vectorTranmissionLayer = new ol.layer.VectorTile({
        source: new ol.source.VectorTile({
            tilePixelRatio: 1, // oversampling when > 1
            projection: 'EPSG:3857',
            format: new ol.format.MVT({
            }),
            tileGrid: ol.tilegrid.createXYZ({
                maxZoom: 19,
            }),
            url: vectorTileUrl
        })
    });

    map.addLayer(vectorTranmissionLayer);


    vectorTransmissionLayerOut = vectorTileLayer;

    previousZoom = zoom;
    */
   
});

var highlightStyle = new ol.style.Style({
    stroke: new ol.style.Stroke({
        color: '#ffcc33', // Glowing color
        width: 4 // Make the line thicker to "glow"
    })
});

var selectedFeature = null; 

        map.on('singleclick', function(event) {


            if(selectedFeature) {
                selectedFeature.setStyle(null);
            }
    // Use the map's forEachFeatureAtPixel method to check for features at the click location
    map.forEachFeatureAtPixel(event.pixel, function(feature, layer) {
        // Check if the layer is the transmissionLineLayer
        if (layer === vectorTransmissionLayerOut) {

                        // Construct content for the popup based on the feature's properties
                        var properties = feature.getProperties();
            var info = `Name: ${properties.OWNER}<br>
                        Length: ${Math.round(properties.SHAPE__Len/1000)} km <br> 
                        Voltage: ${properties.VOLTAGE}<br>
                        Substation 1: ${properties.SUB_1}<br>
                        Substation 2: ${properties.SUB_2}`;
            content.innerHTML = info;

            // Show the popup
            var coordinate = event.coordinate;
            overlay.setPosition(coordinate);

            if(selectedFeature) {
                selectedFeature.setStyle(null);
            }

            selectedFeature = feature;
            
            // Highlight the feature
            feature.setStyle(highlightStyle);
            selectedFeature = feature;

            // Log the feature to the console
            console.log(feature);
            // Optionally, return the feature if you only want the first feature found
            return feature;
        }
    }, {
        // Specify the layer(s) to include in the search
        layerFilter: function(candidateLayer) {
            return candidateLayer === vectorTransmissionLayerOut;
        }
    });
});

var dragging = false;
var offsetX, offsetY;

// Assuming 'overlay' is your popup overlay and 'container' is the HTML element of the popup
var container = document.getElementById('popup'); // Adjust the ID to match your popup's container

container.addEventListener('mousedown', function(event) {
    // Start dragging
    if(container.contains(event.target)){
        dragging = true;
        var rect = container.getBoundingClientRect();
        console.log(rect.left)
        console.log(rect.top)
        //Get location of the left and top of the container
        offsetX = event.clientX -parseFloat(rect.left)//- parseFloat(container.style.left);
        offsetY = event.clientY -parseFloat(rect.top) // parseFloat(container.style.top);
        container.style.cursor = 'grabbing';
        console.log("Grabbing")
        console.log("OffsetX: " + offsetX)
        console.log("OffsetY: " + offsetY)
        event.preventDefault();
    }
});

document.addEventListener('mousemove', function(event) {
    if (dragging) {
        // Calculate the new position
        var x = event.clientX - offsetX;
        var y = event.clientY - offsetY;

        console.log("Dragging")
        console.log("X: " + x)
        console.log("Y: " + y)

        

        // Update the position of the popup
        container.style.left = x-650 + 'px';
        container.style.top = y-40 + 'px';
    }
});

document.addEventListener('mouseup', function() {
    // Stop dragging
    dragging = false;
    container.style.cursor = 'grab';
});

// Prevent text selection while dragging
container.addEventListener('selectstart', function(event) {
    event.preventDefault();
});
        

        map.on('singleclick', function(evt) {
    var infoPanel = document.getElementById('info');
    var featureFound = false;
    map.forEachFeatureAtPixel(evt.pixel, function(feature, layer) {
        // Assuming your features have properties you want to display
        // Adjust this to match the actual properties of your features
        var properties = feature.getProperties();
        console.log(properties);
        var infoContent = 'Power Plant Name: ' + properties.Plant_Name; // Example property
        infoPanel.innerHTML = infoContent;
        featureFound = true;
    });

    map.on('moveend', function() {
    var zoom = map.getView().getZoom();
    // Adjust clusterSource distance or clusterLayer style based on zoom
    // For example, disable clustering at high zoom levels  
    var certainZoomLevel = 10;
    if (zoom > certainZoomLevel) {
        clusterSource.setDistance(0); // No clustering
    } else {
        clusterSource.setDistance(40); // Adjust distance as needed
    }
});

    if (!featureFound) {
        infoPanel.innerHTML = 'Click on a point';
    }
});
    </script>
</body>
</html>